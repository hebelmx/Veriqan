#!/usr/bin/env python3
"""Locate and optionally delete stray XunitAutoGeneratedEntryPoint artifacts."""

from __future__ import annotations

import argparse
import pathlib
import sys
from typing import Iterable, List

SCRIPT_PATH = pathlib.Path(__file__).resolve()
REPO_ROOT = SCRIPT_PATH.parents[1]


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description=(
            "Find files whose names start with 'XunitAutoGeneratedEntryPoint' (or a custom "
            "pattern) and remove them. Defaults to a dry run."
        )
    )
    parser.add_argument(
        "--root",
        type=pathlib.Path,
        default=REPO_ROOT,
        help=f"Directory to scan recursively (default: {REPO_ROOT}).",
    )
    parser.add_argument(
        "--pattern",
        default="XunitAutoGeneratedEntryPoint*",
        help="Glob pattern to match (default: 'XunitAutoGeneratedEntryPoint*').",
    )
    parser.add_argument(
        "--apply",
        action="store_true",
        help="Actually delete the matched files. Without this flag the script only prints them.",
    )
    return parser.parse_args()


def find_matches(root: pathlib.Path, pattern: str) -> List[pathlib.Path]:
    matches: List[pathlib.Path] = []
    try:
        iterator = root.rglob(pattern)
    except Exception as exc:  # pylint: disable=broad-exception-caught
        print(f"[error] Failed to scan {root}: {exc}", file=sys.stderr)
        return matches

    for path in iterator:
        if path.is_file():
            matches.append(path)
    return matches


def delete_files(paths: Iterable[pathlib.Path]) -> None:
    for path in paths:
        try:
            path.unlink()
            print(f"Deleted {path}")
        except FileNotFoundError:
            print(f"[warn] Skipped (missing): {path}")
        except PermissionError:
            print(f"[warn] Permission denied: {path}")
        except OSError as exc:
            print(f"[warn] Could not delete {path}: {exc}")


def main() -> int:
    args = parse_args()
    root = args.root.resolve()
    if not root.exists():
        print(f"[error] Root directory does not exist: {root}", file=sys.stderr)
        return 1

    matches = find_matches(root, args.pattern)
    if not matches:
        print(f"No files matching '{args.pattern}' were found under {root}.")
        return 0

    print(f"Found {len(matches)} file(s) matching '{args.pattern}':")
    for match in matches:
        print(f"  - {match}")

    if not args.apply:
        print("\nDry run only. Re-run with --apply to delete these files.")
        return 0

    delete_files(matches)
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
