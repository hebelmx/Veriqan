"""
Simple API Interface - Clean, minimal interface for external consumption.
"""

from typing import Dict, Any, Optional, Union, List
from pathlib import Path

from .factory import ExtractorFactory, create_extractor, extract_from_image, extract_from_images
from .modules import ConfigManager, PerformanceMonitor, ErrorHandler


class PrismaExtractorAPI:
    """
    High-level API for Prisma AI Extractors.
    Single Responsibility: Provide simple, clean interface for external use.
    """
    
    def __init__(self, config: Optional[Union[str, Path, Dict[str, Any]]] = None):
        \"\"\"Initialize API with optional configuration.\"\"\"\n        self.factory = ExtractorFactory(config)\n        self.active_extractors = {}\n        \n        # Global performance monitor\n        self.performance_monitor = PerformanceMonitor()\n        \n        # Global error handler\n        self.error_handler = ErrorHandler()\n    \n    def extract(\n        self,\n        image_path: Union[str, Path],\n        extractor: str = 'smolvlm',\n        **config_overrides\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Extract structured data from a single image.\n        \n        Args:\n            image_path: Path to image file\n            extractor: Extractor type ('smolvlm', 'paddle', 'doctr')\n            **config_overrides: Configuration overrides\n            \n        Returns:\n            Dictionary with extraction results\n        \"\"\"\n        with self.performance_monitor.track_operation(\"api_extract\"):\n            try:\n                # Get or create extractor\n                if extractor not in self.active_extractors:\n                    self.active_extractors[extractor] = self.factory.create_extractor(\n                        extractor, config_overrides\n                    )\n                \n                extractor_instance = self.active_extractors[extractor]\n                result = extractor_instance.extract(image_path)\n                \n                # Convert to simple dictionary\n                return self._format_result(result)\n                \n            except Exception as e:\n                error_info = self.error_handler.handle_error(\n                    e,\n                    context={'image_path': str(image_path), 'extractor': extractor}\n                )\n                return {\n                    'success': False,\n                    'error': str(e),\n                    'error_info': error_info\n                }\n    \n    def extract_batch(\n        self,\n        image_paths: List[Union[str, Path]],\n        extractor: str = 'smolvlm',\n        **config_overrides\n    ) -> List[Dict[str, Any]]:\n        \"\"\"\n        Extract from multiple images.\n        \n        Args:\n            image_paths: List of image paths\n            extractor: Extractor type\n            **config_overrides: Configuration overrides\n            \n        Returns:\n            List of extraction results\n        \"\"\"\n        results = []\n        \n        for image_path in image_paths:\n            result = self.extract(image_path, extractor, **config_overrides)\n            results.append(result)\n        \n        return results\n    \n    def compare_extractors(\n        self,\n        image_path: Union[str, Path],\n        extractors: Optional[List[str]] = None\n    ) -> Dict[str, Dict[str, Any]]:\n        \"\"\"\n        Compare results from multiple extractors.\n        \n        Args:\n            image_path: Path to image\n            extractors: List of extractors to compare (all if None)\n            \n        Returns:\n            Dictionary with results from each extractor\n        \"\"\"\n        if extractors is None:\n            extractors = self.factory.get_available_extractors()\n        \n        results = {}\n        \n        for extractor_name in extractors:\n            results[extractor_name] = self.extract(image_path, extractor_name)\n        \n        return results\n    \n    def get_performance_report(self) -> Dict[str, Any]:\n        \"\"\"Get comprehensive performance report.\"\"\"\n        # Combine API-level and extractor-level performance\n        api_performance = self.performance_monitor.get_report()\n        \n        extractor_performance = {}\n        for name, extractor in self.active_extractors.items():\n            extractor_performance[name] = extractor.get_performance_report()\n        \n        return {\n            'api_level': api_performance,\n            'extractors': extractor_performance\n        }\n    \n    def get_error_statistics(self) -> Dict[str, Any]:\n        \"\"\"Get error statistics.\"\"\"\n        # Combine API-level and extractor-level errors\n        api_errors = self.error_handler.get_error_stats()\n        \n        extractor_errors = {}\n        for name, extractor in self.active_extractors.items():\n            extractor_errors[name] = extractor.get_error_stats()\n        \n        return {\n            'api_level': api_errors,\n            'extractors': extractor_errors\n        }\n    \n    def cleanup(self):\n        \"\"\"Cleanup resources.\"\"\"\n        for extractor in self.active_extractors.values():\n            extractor.cleanup()\n        \n        self.active_extractors.clear()\n        self.performance_monitor.clear_history()\n        self.error_handler.clear_stats()\n    \n    def _format_result(self, extraction_result) -> Dict[str, Any]:\n        \"\"\"Format ExtractionResult for API response.\"\"\"\n        result = {\n            'success': extraction_result.success,\n            'processing_time': extraction_result.processing_time,\n            'extractor': extraction_result.extractor_name\n        }\n        \n        if extraction_result.success:\n            result['data'] = extraction_result.document.structured_data\n            result['metadata'] = extraction_result.document.metadata\n        else:\n            result['error'] = extraction_result.error_message\n            if hasattr(extraction_result, 'metadata'):\n                result['error_details'] = extraction_result.metadata\n        \n        return result\n    \n    def __enter__(self):\n        \"\"\"Context manager entry.\"\"\"\n        return self\n    \n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Context manager exit with cleanup.\"\"\"\n        self.cleanup()\n\n\n# Convenience functions for simple usage\ndef quick_extract(\n    image_path: Union[str, Path],\n    extractor: str = 'smolvlm'\n) -> Dict[str, Any]:\n    \"\"\"\n    Quick extraction with minimal setup.\n    \n    Args:\n        image_path: Path to image\n        extractor: Extractor type\n        \n    Returns:\n        Extraction result\n    \"\"\"\n    with PrismaExtractorAPI() as api:\n        return api.extract(image_path, extractor)\n\n\ndef quick_extract_batch(\n    image_paths: List[Union[str, Path]],\n    extractor: str = 'smolvlm'\n) -> List[Dict[str, Any]]:\n    \"\"\"\n    Quick batch extraction.\n    \n    Args:\n        image_paths: List of image paths\n        extractor: Extractor type\n        \n    Returns:\n        List of extraction results\n    \"\"\"\n    with PrismaExtractorAPI() as api:\n        return api.extract_batch(image_paths, extractor)\n\n\ndef compare_all_extractors(\n    image_path: Union[str, Path]\n) -> Dict[str, Dict[str, Any]]:\n    \"\"\"\n    Compare all available extractors on a single image.\n    \n    Args:\n        image_path: Path to image\n        \n    Returns:\n        Comparison results\n    \"\"\"\n    with PrismaExtractorAPI() as api:\n        return api.compare_extractors(image_path)