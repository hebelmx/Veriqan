# UI/UX Enhancements: Story 1.1 - Browser Automation and Document Download

**Story:** 1.1 - Browser Automation and Document Download  
**Status:** UX Enhancement Recommendations  
**Created:** 2025-01-15  
**Last Updated:** 2025-01-15

---

## Current State Analysis

**Backend Status:** ‚úÖ Complete (QA Approved)  
**UI Status:** ‚ö†Ô∏è **Partial** - Basic infrastructure exists, enhanced dashboard needed

**Gaps Identified:**
- No dedicated UI for browser automation download results
- No visibility into automated download history
- No real-time download status updates
- No duplicate detection visualization
- No download statistics dashboard

---

## Required UI Components

### 1. Document Ingestion Dashboard

**Location:** `Components/Pages/DocumentIngestionDashboard.razor`  
**Purpose:** Central hub for monitoring automated document downloads and manual uploads

**Features:**

**A. Download History Table**
- **Columns:**
  - File Name (with icon based on format)
  - Source URL (truncated, clickable link)
  - Download Timestamp (relative time + absolute)
  - File Size (formatted: KB/MB)
  - Format Badge (PDF/XML/DOCX/ZIP)
  - Status Badge (Success/Duplicate/Failed)
  - Checksum (truncated, expandable)
  - Actions (View Metadata, Download, View Processing Status)

- **Filtering:**
  - Date range picker
  - Format filter (multi-select)
  - Status filter (Success/Duplicate/Failed)
  - Search by filename or URL

- **Sorting:**
  - By timestamp (newest/oldest first)
  - By file name (A-Z)
  - By file size (largest/smallest)
  - By status

**B. Download Statistics Cards**
- **Metrics:**
  - Total files downloaded (today/week/month/all-time)
  - Duplicate detection count (with percentage)
  - Failed downloads count (with error breakdown)
  - Average download time
  - Total storage used
  - Files pending processing

- **Visual Design:**
  - Large number with trend indicator (‚Üë/‚Üì)
  - Mini chart showing trend over time
  - Clickable cards that filter the table

**C. Browser Automation Status Panel**
- **Information:**
  - Last automation run timestamp
  - Next scheduled run (if configured)
  - Automation health status (success rate, error count)
  - Current browser session status (if running)
  - Configuration summary (website URL, file patterns)

- **Actions:**
  - Manual trigger button (with confirmation)
  - View automation logs
  - Configure automation settings

**D. Recent Downloads Feed**
- Real-time updates via SignalR (using `Dashboard<FileMetadata>` from Story 1.10)
- Shows last 10-20 downloads with status indicators
- Expandable to show full history
- Visual indicators for new downloads

---

## Implementation Code

### Document Ingestion Dashboard Component

```razor
@page "/document-ingestion"
@using ExxerCube.Prisma.Domain.Entities
@using ExxerCube.Prisma.Application.Services
@using ExxerCube.Prisma.SignalR.Abstractions
@inject IDocumentIngestionService DocumentIngestionService
@inject IFileMetadataLogger FileMetadataLogger
@inject IDashboard<FileMetadata> DashboardService
@inject ILogger<DocumentIngestionDashboard> Logger
@implements IAsyncDisposable

<PageTitle>Document Ingestion Dashboard</PageTitle>

<MudContainer MaxWidth="MaxWidth.ExtraLarge" Class="mt-4">
    <MudText Typo="Typo.h4" Class="mb-4">
        <MudIcon Icon="@Icons.Material.Filled.CloudDownload" Class="mr-2" />
        Document Ingestion Dashboard
    </MudText>

    <!-- Connection State Indicator -->
    <ConnectionStateIndicator ConnectionState="@connectionState" Class="mb-2" />

    <!-- Statistics Cards -->
    <MudGrid Class="mb-4">
        <MudItem xs="12" sm="6" md="3">
            <MudCard OnClick="@(() => FilterByStatus("Success"))" Class="cursor-pointer">
                <MudCardContent>
                    <MudText Typo="Typo.h4" Color="Color.Success">@totalDownloads</MudText>
                    <MudText Typo="Typo.body2">Total Downloads</MudText>
                    <MudText Typo="Typo.caption" Color="Color.Secondary">
                        @(duplicateCount) duplicates detected
                    </MudText>
                </MudCardContent>
            </MudCard>
        </MudItem>
        <MudItem xs="12" sm="6" md="3">
            <MudCard OnClick="@(() => FilterByStatus("Failed"))" Class="cursor-pointer">
                <MudCardContent>
                    <MudText Typo="Typo.h4" Color="Color.Error">@failedDownloads</MudText>
                    <MudText Typo="Typo.body2">Failed Downloads</MudText>
                    <MudText Typo="Typo.caption" Color="Color.Secondary">
                        @(failedPercentage.ToString("F1"))% failure rate
                    </MudText>
                </MudCardContent>
            </MudCard>
        </MudItem>
        <MudItem xs="12" sm="6" md="3">
            <MudCard>
                <MudCardContent>
                    <MudText Typo="Typo.h4" Color="Color.Info">@FormatFileSize(totalStorageUsed)</MudText>
                    <MudText Typo="Typo.body2">Total Storage Used</MudText>
                    <MudText Typo="Typo.caption" Color="Color.Secondary">
                        @FormatFileSize((long)averageFileSize) avg file size
                    </MudText>
                </MudCardContent>
            </MudCard>
        </MudItem>
        <MudItem xs="12" sm="6" md="3">
            <MudCard>
                <MudCardContent>
                    <MudText Typo="Typo.h4" Color="Color.Warning">@pendingProcessing</MudText>
                    <MudText Typo="Typo.body2">Pending Processing</MudText>
                    <MudText Typo="Typo.caption" Color="Color.Secondary">
                        Awaiting extraction
                    </MudText>
                </MudCardContent>
            </MudCard>
        </MudItem>
    </MudGrid>

    <!-- Browser Automation Status -->
    <MudCard Class="mb-4">
        <MudCardHeader>
            <MudText Typo="Typo.h6">
                <MudIcon Icon="@Icons.Material.Filled.Settings" Class="mr-2" />
                Browser Automation Status
            </MudText>
        </MudCardHeader>
        <MudCardContent>
            <MudGrid>
                <MudItem xs="12" sm="6" md="3">
                    <MudText Typo="Typo.subtitle2">Last Run</MudText>
                    <MudText Typo="Typo.body1">
                        @(lastRunTime?.ToString("g") ?? "Never")
                    </MudText>
                </MudItem>
                <MudItem xs="12" sm="6" md="3">
                    <MudText Typo="Typo.subtitle2">Success Rate</MudText>
                    <MudProgressLinear Value="@successRate" Color="@GetSuccessRateColor(successRate)" />
                    <MudText Typo="Typo.body2">@(successRate.ToString("F1"))%</MudText>
                </MudItem>
                <MudItem xs="12" sm="6" md="3">
                    <MudText Typo="Typo.subtitle2">Status</MudText>
                    <MudChip Size="Size.Small" Color="@GetStatusColor(automationStatus)">
                        @automationStatus
                    </MudChip>
                </MudItem>
                <MudItem xs="12" sm="6" md="3">
                    <MudButton Variant="Variant.Filled" 
                               Color="Color.Primary"
                               StartIcon="@Icons.Material.Filled.PlayArrow"
                               OnClick="TriggerManualDownloadAsync"
                               Disabled="@isDownloading">
                        @(isDownloading ? "Downloading..." : "Trigger Download")
                    </MudButton>
                </MudItem>
            </MudGrid>
        </MudCardContent>
    </MudCard>

    <!-- Download History Table -->
    <MudCard>
        <MudCardHeader>
            <MudText Typo="Typo.h6">Download History</MudText>
            <MudSpacer />
            <MudTextField @bind-Value="searchText" 
                         Placeholder="Search files..." 
                         Adornment="Adornment.Start"
                         AdornmentIcon="@Icons.Material.Filled.Search"
                         Variant="Variant.Outlined"
                         Dense="true"
                         Immediate="true" />
        </MudCardHeader>
        <MudCardContent>
            @if (isLoading)
            {
                <MudProgressLinear Indeterminate="true" />
            }
            else if (errorMessage != null)
            {
                <MudAlert Severity="Severity.Error">@errorMessage</MudAlert>
            }
            else
            {
                <MudTable Items="@filteredDownloads" 
                         Dense="true" 
                         Hover="true" 
                         Striped="true"
                         Filter="new Func<FileMetadata, bool>(FilterDownloads)"
                         SortMode="SortMode.Multiple">
                    <HeaderContent>
                        <MudTh>
                            <MudTableSortLabel SortBy="@new Func<FileMetadata, object>(x => x.FileName)">
                                File Name
                            </MudTableSortLabel>
                        </MudTh>
                        <MudTh>
                            <MudTableSortLabel SortBy="@new Func<FileMetadata, object>(x => x.Url)">
                                Source URL
                            </MudTableSortLabel>
                        </MudTh>
                        <MudTh>
                            <MudTableSortLabel SortBy="@new Func<FileMetadata, object>(x => x.DownloadTimestamp)">
                                Downloaded
                            </MudTableSortLabel>
                        </MudTh>
                        <MudTh>
                            <MudTableSortLabel SortBy="@new Func<FileMetadata, object>(x => x.FileSize)">
                                Size
                            </MudTableSortLabel>
                        </MudTh>
                        <MudTh>Format</MudTh>
                        <MudTh>Status</MudTh>
                        <MudTh>Actions</MudTh>
                    </HeaderContent>
                    <RowTemplate>
                        <MudTd DataLabel="File Name">
                            <MudIcon Icon="@GetFormatIcon(context.Format)" Class="mr-2" />
                            <MudText Typo="Typo.body2">@context.FileName</MudText>
                        </MudTd>
                        <MudTd DataLabel="Source URL">
                            @if (!string.IsNullOrEmpty(context.Url))
                            {
                                <MudLink Href="@context.Url" Target="_blank" Color="Color.Primary">
                                    @TruncateUrl(context.Url, 40)
                                </MudLink>
                            }
                            else
                            {
                                <MudText Typo="Typo.body2" Color="Color.Secondary">Manual Upload</MudText>
                            }
                        </MudTd>
                        <MudTd DataLabel="Downloaded">
                            <MudText Typo="Typo.body2">@context.DownloadTimestamp.ToString("g")</MudText>
                            <MudText Typo="Typo.caption" Color="Color.Secondary">
                                @GetRelativeTime(context.DownloadTimestamp)
                            </MudText>
                        </MudTd>
                        <MudTd DataLabel="Size">
                            <MudText Typo="Typo.body2">@FormatFileSize(context.FileSize)</MudText>
                        </MudTd>
                        <MudTd DataLabel="Format">
                            <MudChip Size="Size.Small" Color="@GetFormatColor(context.Format)">
                                @context.Format
                            </MudChip>
                        </MudTd>
                        <MudTd DataLabel="Status">
                            <MudChip Size="Size.Small" 
                                    Color="@GetStatusColor(context.Status)"
                                    Icon="@GetStatusIcon(context.Status)">
                                @context.Status
                            </MudChip>
                        </MudTd>
                        <MudTd DataLabel="Actions">
                            <MudIconButton Icon="@Icons.Material.Filled.Visibility" 
                                          Size="Size.Small"
                                          OnClick="@(() => ViewMetadataAsync(context))" />
                            <MudIconButton Icon="@Icons.Material.Filled.Download" 
                                          Size="Size.Small"
                                          OnClick="@(() => DownloadFileAsync(context))" />
                            <MudIconButton Icon="@Icons.Material.Filled.Info" 
                                          Size="Size.Small"
                                          OnClick="@(() => ViewProcessingStatusAsync(context))" />
                        </MudTd>
                    </RowTemplate>
                    <PagerContent>
                        <MudTablePager />
                    </PagerContent>
                </MudTable>
            }
        </MudCardContent>
    </MudCard>

    <!-- Filters Panel -->
    <MudExpansionPanels Class="mt-4">
        <MudExpansionPanel Text="Filters">
            <MudGrid>
                <MudItem xs="12" sm="6" md="3">
                    <MudDatePicker Label="From Date" @bind-Date="filterFromDate" />
                </MudItem>
                <MudItem xs="12" sm="6" md="3">
                    <MudDatePicker Label="To Date" @bind-Date="filterToDate" />
                </MudItem>
                <MudItem xs="12" sm="6" md="3">
                    <MudSelect Label="Format" @bind-SelectedValue="selectedFormat" MultiSelection="true">
                        @foreach (var format in Enum.GetValues<FileFormat>())
                        {
                            <MudSelectItem Value="@format">@format</MudSelectItem>
                        }
                    </MudSelect>
                </MudItem>
                <MudItem xs="12" sm="6" md="3">
                    <MudSelect Label="Status" @bind-SelectedValue="selectedStatus" MultiSelection="true">
                        <MudSelectItem Value="Success">Success</MudSelectItem>
                        <MudSelectItem Value="Duplicate">Duplicate</MudSelectItem>
                        <MudSelectItem Value="Failed">Failed</MudSelectItem>
                    </MudSelect>
                </MudItem>
            </MudGrid>
        </MudExpansionPanel>
    </MudExpansionPanels>
</MudContainer>

@code {
    private readonly List<FileMetadata> downloads = new();
    private readonly List<FileMetadata> filteredDownloads = new();
    private string searchText = string.Empty;
    private DateTime? filterFromDate;
    private DateTime? filterToDate;
    private FileFormat? selectedFormat;
    private string? selectedStatus;
    private bool isDownloading = false;
    private bool isLoading = false;
    private string? errorMessage;
    private string automationStatus = "Idle";
    private DateTime? lastRunTime;
    private double successRate = 0;
    private ConnectionState connectionState = ConnectionState.Disconnected;
    private CancellationTokenSource? cancellationTokenSource;

    private int totalDownloads => downloads.Count;
    private int duplicateCount => downloads.Count(d => d.Status == "Duplicate");
    private int failedDownloads => downloads.Count(d => d.Status == "Failed");
    private double failedPercentage => totalDownloads > 0 ? (failedDownloads * 100.0 / totalDownloads) : 0;
    private long totalStorageUsed => downloads.Sum(d => d.FileSize);
    private double averageFileSize => totalDownloads > 0 ? downloads.Average(d => d.FileSize) : 0;
    private int pendingProcessing => downloads.Count(d => d.Status == "Success" && !d.IsProcessed);

    protected override async Task OnInitializedAsync()
    {
        cancellationTokenSource = new CancellationTokenSource();
        await LoadDownloadHistoryAsync(cancellationTokenSource.Token);
        await InitializeSignalRConnectionAsync(cancellationTokenSource.Token);
    }

    private async Task LoadDownloadHistoryAsync(CancellationToken cancellationToken)
    {
        isLoading = true;
        errorMessage = null;
        StateHasChanged();

        try
        {
            Logger.LogInformation("Loading download history");
            var result = await FileMetadataLogger.GetAllAsync(cancellationToken);
            
            if (result.IsFailure)
            {
                Logger.LogWarning("Failed to load download history: {Error}", result.Error);
                errorMessage = $"Failed to load download history: {result.Error}";
                return;
            }

            downloads.Clear();
            downloads.AddRange(result.Value);
            ApplyFilters();
            
            Logger.LogInformation("Loaded {Count} download records", downloads.Count);
        }
        catch (OperationCanceledException)
        {
            Logger.LogInformation("Load download history cancelled");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading download history");
            errorMessage = $"Error loading download history: {ex.Message}";
        }
        finally
        {
            isLoading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task InitializeSignalRConnectionAsync(CancellationToken cancellationToken)
    {
        try
        {
            Logger.LogInformation("Initializing SignalR connection for download updates");
            connectionState = ConnectionState.Connecting;
            await InvokeAsync(StateHasChanged);

            var subscribeResult = await DashboardService.SubscribeAsync("downloads", cancellationToken);
            if (subscribeResult.IsFailure)
            {
                Logger.LogWarning("Failed to subscribe to download updates: {Error}", subscribeResult.Error);
                connectionState = ConnectionState.Failed;
                return;
            }

            connectionState = ConnectionState.Connected;
            Logger.LogInformation("Successfully connected to download updates hub");
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error initializing SignalR connection");
            connectionState = ConnectionState.Failed;
            await InvokeAsync(StateHasChanged);
        }
    }

    private void ApplyFilters()
    {
        filteredDownloads.Clear();
        filteredDownloads.AddRange(downloads.Where(FilterDownloads));
    }

    private bool FilterDownloads(FileMetadata file)
    {
        if (!string.IsNullOrEmpty(searchText) && 
            !file.FileName.Contains(searchText, StringComparison.OrdinalIgnoreCase) &&
            !(file.Url?.Contains(searchText, StringComparison.OrdinalIgnoreCase) ?? false))
        {
            return false;
        }
        
        if (filterFromDate.HasValue && file.DownloadTimestamp < filterFromDate.Value)
            return false;
            
        if (filterToDate.HasValue && file.DownloadTimestamp > filterToDate.Value)
            return false;
            
        if (selectedFormat.HasValue && file.Format != selectedFormat.Value)
            return false;
            
        if (!string.IsNullOrEmpty(selectedStatus) && file.Status != selectedStatus)
            return false;
            
        return true;
    }

    private async Task TriggerManualDownloadAsync()
    {
        if (isDownloading || cancellationTokenSource == null)
            return;

        isDownloading = true;
        await InvokeAsync(StateHasChanged);
        
        try
        {
            Logger.LogInformation("Triggering manual download");
            var result = await DocumentIngestionService.TriggerDownloadAsync(cancellationTokenSource.Token);
            
            if (result.IsFailure)
            {
                Logger.LogWarning("Failed to trigger download: {Error}", result.Error);
                errorMessage = $"Failed to trigger download: {result.Error}";
                return;
            }

            Logger.LogInformation("Download triggered successfully");
            await LoadDownloadHistoryAsync(cancellationTokenSource.Token);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error triggering manual download");
            errorMessage = $"Error triggering download: {ex.Message}";
        }
        finally
        {
            isDownloading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task ViewMetadataAsync(FileMetadata file)
    {
        Logger.LogInformation("Viewing metadata for file {FileId}", file.FileId);
        // Navigate to metadata viewer or open dialog
        // Implementation depends on navigation service
    }

    private async Task DownloadFileAsync(FileMetadata file)
    {
        Logger.LogInformation("Downloading file {FileId}", file.FileId);
        // Trigger file download
        // Implementation depends on file download service
    }

    private async Task ViewProcessingStatusAsync(FileMetadata file)
    {
        Logger.LogInformation("Viewing processing status for file {FileId}", file.FileId);
        // Navigate to processing status page
        // Implementation depends on navigation service
    }

    private void FilterByStatus(string status)
    {
        selectedStatus = selectedStatus == status ? null : status;
        ApplyFilters();
        InvokeAsync(StateHasChanged);
    }

    private string FormatFileSize(long bytes) => bytes switch
    {
        >= 1073741824 => $"{bytes / 1073741824.0:F2} GB",
        >= 1048576 => $"{bytes / 1048576.0:F2} MB",
        >= 1024 => $"{bytes / 1024.0:F2} KB",
        _ => $"{bytes} B"
    };

    private string TruncateUrl(string url, int maxLength) =>
        url.Length > maxLength ? url[..maxLength] + "..." : url;

    private string GetRelativeTime(DateTime timestamp)
    {
        var span = DateTimeOffset.UtcNow - timestamp;
        return span.TotalMinutes < 1 ? "Just now" :
               span.TotalHours < 1 ? $"{(int)span.TotalMinutes}m ago" :
               span.TotalDays < 1 ? $"{(int)span.TotalHours}h ago" :
               $"{(int)span.TotalDays}d ago";
    }

    private string GetFormatIcon(FileFormat format) => format switch
    {
        FileFormat.PDF => Icons.Material.Filled.PictureAsPdf,
        FileFormat.XML => Icons.Material.Filled.Code,
        FileFormat.DOCX => Icons.Material.Filled.Description,
        FileFormat.ZIP => Icons.Material.Filled.Archive,
        _ => Icons.Material.Filled.InsertDriveFile
    };

    private Color GetFormatColor(FileFormat format) => format switch
    {
        FileFormat.PDF => Color.Error,
        FileFormat.XML => Color.Info,
        FileFormat.DOCX => Color.Primary,
        FileFormat.ZIP => Color.Warning,
        _ => Color.Default
    };

    private Color GetStatusColor(string status) => status switch
    {
        "Success" => Color.Success,
        "Duplicate" => Color.Info,
        "Failed" => Color.Error,
        _ => Color.Default
    };

    private string GetStatusIcon(string status) => status switch
    {
        "Success" => Icons.Material.Filled.CheckCircle,
        "Duplicate" => Icons.Material.Filled.ContentCopy,
        "Failed" => Icons.Material.Filled.Error,
        _ => Icons.Material.Filled.Help
    };

    private Color GetSuccessRateColor(double rate) => rate switch
    {
        >= 95 => Color.Success,
        >= 80 => Color.Warning,
        _ => Color.Error
    };

    public async ValueTask DisposeAsync()
    {
        if (cancellationTokenSource != null)
        {
            cancellationTokenSource.Cancel();
            cancellationTokenSource.Dispose();
        }

        if (connectionState == ConnectionState.Connected)
        {
            try
            {
                await DashboardService.UnsubscribeAsync("downloads", CancellationToken.None);
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error unsubscribing from download updates");
            }
        }
    }
}
```

### File Metadata Viewer Component

**Location:** `Components/Shared/FileMetadataViewer.razor`  
**Purpose:** Display detailed file metadata in a dialog or dedicated page

**Features:**
- File details card (all FileMetadata properties)
- Related documents link (if file was processed)
- Download history (show if file was previously downloaded)
- Checksum verification status
- Processing pipeline status

---

## Code Standards Compliance

### ‚úÖ Result<T> Pattern
- All service calls return `Result<T>`
- Error handling uses Railway-Oriented Programming
- No exceptions for control flow

### ‚úÖ CancellationToken Support
- All async methods accept `CancellationToken`
- Proper cancellation handling throughout
- `CancellationTokenSource` properly disposed

### ‚úÖ Structured Logging
- Uses `ILogger<T>` with structured logging
- Logs key operations, errors, and non-normal flows
- Uses appropriate log levels

### ‚úÖ Expression-Bodied Members
- Simple methods use expression-bodied syntax
- Switch expressions for format/status mapping

### ‚úÖ SignalR Integration
- Uses `Dashboard<FileMetadata>` abstraction from Story 1.10
- Proper connection state management
- Automatic reconnection handling

### ‚úÖ Immutability
- Uses `ReadOnlyCollections` where appropriate
- Prefers `init` properties

---

## Testing Considerations

### Unit Tests
- Test filtering logic
- Test format/status mapping functions
- Test file size formatting
- Test relative time calculation

### Integration Tests
- Test SignalR connection and updates
- Test download history loading
- Test manual download trigger
- Test error handling scenarios

---

## Related Documentation

- [Story 1.1: Browser Automation](../../stories/1.1.browser-automation-document-download.md)
- [ADR-001: SignalR Unified Hub Abstraction](../../adr/ADR-001-SignalR-Unified-Hub-Abstraction.md)
- [Story 1.10: SignalR Infrastructure](../../stories/1.10.signalr-unified-hub-abstraction.md)
- [Sharding Approach](./SHARDING-APPROACH.md)

---

**Document Status:** ‚úÖ **Complete**  
**Ready for Implementation** üöÄ

